// This file is automatically generated by Keystone, do not modify it manually.
// Modify your Keystone config when you want to change this.

datasource postgresql {
  url      = env("DATABASE_URL")
  provider = "postgresql"
}

generator client {
  provider = "prisma-client-js"
  output   = "node_modules/.prisma/client"
}

model User {
  id                      String       @id @default(uuid()) @postgresql.Uuid
  firstName               String       @default("") @map("first_name")
  lastName                String       @default("") @map("last_name")
  email                   String       @unique @default("")
  password                String
  registered              DateTime?    @default(now())
  role                    Role?        @relation("User_role", fields: [roleId], references: [id])
  roleId                  String?      @map("role") @postgresql.Uuid
  invitation              Invitation?  @relation("User_invitation", fields: [invitationId], references: [id])
  invitationId            String?      @map("invitation") @postgresql.Uuid
  createdInvitations      Invitation[] @relation("Invitation_createdBy")
  authoredTeams           Team[]       @relation("Team_author")
  managedTeams            Team[]       @relation("Team_managers")
  assignedTeams           Team[]       @relation("Team_members")
  authoredSkills          Skill[]      @relation("Skill_author")
  authoredLevels          Level[]      @relation("Level_author")
  userLevels              UserLevel[]  @relation("UserLevel_user")
  passwordResetToken      String?
  passwordResetIssuedAt   DateTime?
  passwordResetRedeemedAt DateTime?

  @@index([roleId])
  @@index([invitationId])
}

model Role {
  id               String  @id @default(uuid()) @postgresql.Uuid
  name             String  @default("")
  canSeeOtherUsers Boolean @default(false)
  canManageUsers   Boolean @default(false)
  canManageRoles   Boolean @default(false)
  asignees         User[]  @relation("User_role")
}

model Invitation {
  id                   String    @id @default(uuid()) @postgresql.Uuid
  email                String    @unique @default("")
  createdBy            User?     @relation("Invitation_createdBy", fields: [createdById], references: [id])
  createdById          String?   @map("createdBy") @postgresql.Uuid
  created              DateTime? @default(now())
  expires              DateTime
  accepted             DateTime?
  from_User_invitation User[]    @relation("User_invitation")

  @@index([createdById])
}

model Team {
  id          String      @id @default(uuid()) @postgresql.Uuid
  name        String      @default("")
  description String      @default("")
  created     DateTime?   @default(now())
  updated     DateTime?   @updatedAt
  skills      Skill[]     @relation("Skill_team")
  levels      Level[]     @relation("Level_team")
  author      User?       @relation("Team_author", fields: [authorId], references: [id])
  authorId    String?     @map("author") @postgresql.Uuid
  managers    User[]      @relation("Team_managers")
  members     User[]      @relation("Team_members")
  userLevels  UserLevel[] @relation("UserLevel_team")

  @@index([authorId])
}

model Skill {
  id          String      @id @default(uuid()) @postgresql.Uuid
  name        String      @default("")
  description String      @default("")
  created     DateTime?   @default(now())
  updated     DateTime?   @updatedAt
  author      User?       @relation("Skill_author", fields: [authorId], references: [id])
  authorId    String?     @map("author") @postgresql.Uuid
  team        Team?       @relation("Skill_team", fields: [teamId], references: [id])
  teamId      String?     @map("team") @postgresql.Uuid
  levels      Level[]     @relation("Level_skill")
  userLevels  UserLevel[] @relation("UserLevel_skill")

  @@index([authorId])
  @@index([teamId])
}

model Level {
  id          String      @id @default(uuid()) @postgresql.Uuid
  name        String      @default("")
  description String      @default("")
  level       Int         @default(0)
  created     DateTime?   @default(now())
  updated     DateTime?   @updatedAt
  author      User?       @relation("Level_author", fields: [authorId], references: [id])
  authorId    String?     @map("author") @postgresql.Uuid
  team        Team?       @relation("Level_team", fields: [teamId], references: [id])
  teamId      String?     @map("team") @postgresql.Uuid
  skill       Skill?      @relation("Level_skill", fields: [skillId], references: [id])
  skillId     String?     @map("skill") @postgresql.Uuid
  userLevels  UserLevel[] @relation("UserLevel_level")

  @@index([authorId])
  @@index([teamId])
  @@index([skillId])
}

model UserLevel {
  id      String    @id @default(uuid()) @postgresql.Uuid
  user    User?     @relation("UserLevel_user", fields: [userId], references: [id])
  userId  String?   @map("user") @postgresql.Uuid
  level   Level?    @relation("UserLevel_level", fields: [levelId], references: [id])
  levelId String?   @map("level") @postgresql.Uuid
  team    Team?     @relation("UserLevel_team", fields: [teamId], references: [id])
  teamId  String?   @map("team") @postgresql.Uuid
  skill   Skill?    @relation("UserLevel_skill", fields: [skillId], references: [id])
  skillId String?   @map("skill") @postgresql.Uuid
  created DateTime? @default(now())
  updated DateTime? @updatedAt

  @@index([userId])
  @@index([levelId])
  @@index([teamId])
  @@index([skillId])
}